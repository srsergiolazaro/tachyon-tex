use lopdf::{Document, Object, StringFormat};
use std::collections::HashMap;
use std::io::Cursor;

/// PoC: Demonstrates surgical replacement of a text object in a PDF.
/// In a real scenario, Tectonic would give us the new object data.
#[test]
fn test_poc_pdf_patch() {
    // 1. Imagine this is our "Master PDF" generated by Tachyon-Tex
    let mut doc = Document::with_version("1.7");
    let pages_id = doc.new_object_id();
    let font_id = doc.add_object(lopdf::dictionary! {
        "Type" => "Font",
        "Subtype" => "Type1",
        "BaseFont" => "Helvetica",
    });
    let resources_id = doc.add_object(lopdf::dictionary! {
        "Font" => lopdf::dictionary! {
            "F1" => font_id,
        },
    });
    
    // Content stream with unique marker
    let content = b"BT /F1 12 Tf 100 700 Td (Original Section Content) Tj ET";
    let content_id = doc.add_object(lopdf::Stream::new(lopdf::dictionary! {}, content.to_vec()));
    
    let page_id = doc.add_object(lopdf::dictionary! {
        "Type" => "Page",
        "Parent" => pages_id,
        "Contents" => content_id,
        "Resources" => resources_id,
        "MediaBox" => vec![0.into(), 0.into(), 595.into(), 842.into()],
    });
    
    doc.objects.insert(pages_id, Object::Dictionary(lopdf::dictionary! {
        "Type" => "Pages",
        "Kids" => vec![page_id.into()],
        "Count" => 1,
    }));
    
    doc.trailer.set("Root", doc.add_object(lopdf::dictionary! {
        "Type" => "Catalog",
        "Pages" => pages_id,
    }));

    // Save "Base" PDF
    let mut base_pdf = Vec::new();
    doc.save_to(&mut base_pdf).unwrap();
    println!("Base PDF size: {} bytes", base_pdf.len());

    // 2. HOT PATCHING: Replace "Original Section Content" with "PATCHED CONTENT"
    // In Tectonic, we would identify that content_id corresponds to Section 3.
    let new_content = b"BT /F1 12 Tf 100 700 Td (PATCHED CONTENT!) Tj ET";
    let mut patched_doc = Document::load_mem(&base_pdf).unwrap();
    
    // Incrementally update the object
    patched_doc.objects.insert(content_id, Object::Stream(lopdf::Stream::new(lopdf::dictionary! {}, new_content.to_vec())));
    
    // Save incrementally (theoretically adding only changed objects)
    let mut patched_pdf = Vec::new();
    patched_doc.save_to(&mut patched_pdf).unwrap();
    println!("Patched PDF size: {} bytes", patched_pdf.len());
    
    // Verify results
    let final_doc = Document::load_mem(&patched_pdf).unwrap();
    let text_stream = final_doc.get_object(content_id).unwrap().as_stream().unwrap();
    let text = std::string::String::from_utf8_lossy(&text_stream.content);
    assert!(text.contains("PATCHED CONTENT!"));
    println!("Proof of Concept Successful: Object {} patched surgically.", content_id.0);
}
